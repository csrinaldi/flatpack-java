/*
 * #%L
 * FlatPack Automatic Source Tool
 * %%
 * Copyright (C) 2012 Perka Inc.
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
entityHeader(entity) ::= <<
// Generated File - DO NOT EDIT

#import \<Foundation/Foundation.h\>
<if(entity.supertype.requireName)>
#import "<entity.supertype.requireName>.h"
<endif>

<entity.entityProperties:{p | @class <p.requireName>;}; wrap, separator="\n">

<docString(entity.docString)>
@interface <entity.requireName> : <entity.supertype.requireName>

<if(entity.properties)>
<entity.properties:property(); separator="\n\n">
<endif>

@end

>>

entity(entity) ::= <<
// Generated File - DO NOT EDIT

#import "<entity.requireName>.h"
<entity.entityProperties:{p | #import "<p.requireName>.h"}; wrap, separator="\n">
#import "FPBaseHasUuid.h"
#import "FPEntityDescription.h"
#import "FPProperty.h"
#import "NSObject+FP.h"

@implementation <entity.requireName>

static FPEntityDescription *_entityDescription;
static NSMutableArray *_allProperties;

+ (void)initialize {
  [super initialize];
  
  _allProperties = [NSMutableArray array];
  
  <entity.properties:propertyAdd(); separator="\n\n">
  
  _entityDescription = [FPEntityDescription newWithDictionary:@{
    @"typeName":@"<entity.typeName>",
    @"superType":[<entity.supertype.requireName> entityDescription],
    @"kind":[<entity.requireName> class],
    @"properties":_allProperties 
  }];
  
  [FPEntityDescription setEntityDescription:_entityDescription forName:@"<entity.typeName>"];
}

+ (FPEntityDescription *)entityDescription {
  return _entityDescription;
}

<if(entity.collectionProperties)>
// initialize collection properties
- (id)init {
  self = [super init];
  if(self != nil) {
    <entity.collectionProperties:{p | _<p.name> = [<p.objcType> new];}; separator="\n">
  }
  return self;
}
<endif>

@end
>>

property(property) ::= <%
<if(property.docString)><docString(property.docString)><\n><endif>
@property (<property.modifiers:{m | <m>}; separator=", ">) <property.objcType> *<property.safeName>;
%>

propertyAdd(property) ::= <<
// <property.name>
[_allProperties addObject:
  [FPProperty setPropertyForUuid:@"<property.uuid>"
                  withDictionary:@{
                    @"name":@"<property.name>",
                    @"kind":[<property.objcType> class]<if(property.impliedProperty)>,<endif>
                    <if(property.impliedProperty)>@"impliedProperty":[FPProperty propertyForUuid:@"<property.impliedProperty.uuid>"]<endif>
                  }]];
>>

/**
 * Emit a doc string, reflowed to fit the current context.
 */
docString(docString) ::= <<
<if(docString)>// <docString.chunks; wrap="\n// ", separator=" "><endif>
>>

apiHeader(api) ::= <<
// Generated File - DO NOT EDIT

#import \<Foundation/Foundation.h\>
#import "FPBaseApi.h"

@interface PerkaBaseApi : FPBaseApi

@end
>>

api(api) ::= <<
// Generated File - DO NOT EDIT

#import "PerkaBaseApi.h"

@implementation PerkaBaseApi

@end
>>

/**
 * Select the kind of endpoint, either one that's documented to return a FlatPackEntity
 * or just return a HttpURLConnection for anything else.
 */
endpoint(end) ::= <<
<docString(end.docString)>
def <end.methodName><endpointArgList()>
  <if(end.queryParameters)>
  to_return = <end.className>.new(self<if(end.pathParameters)>, <end.pathParameters:{x|<x.name>}; separator=", "><endif>)
  <else>
  to_return = Flatpack::Client::<if(end.returnType)>FlatpackRequest<else>Request<endif>.new(self, "<end.method>", "<end.pathDecoded>"<if(end.pathParameters)>, <end.pathParameters:{x|<x.name>}; separator=", "><endif>)
  <endif>
  <if(end.entity)>to_return.entity = entity<endif>
  to_return
end

>>

endpointPrivate(end) ::= <<
<if(end.queryParameters)>
class <end.className> \< Flatpack::Client::<if(end.returnType)>FlatpackRequest<else>Request<endif>
    
  def initialize(api, *args)
    super(api, "<end.method>", "<end.pathDecoded>", *args)
  end
      
  <end.queryParameters:endpointQueryParameterStub(); separator="\n">
end
    
<endif>
>>

endpointArgList() ::= <%
<if(end.entity && end.pathParameters)>
  (entity, <end.pathParameters:{x |<x.name>}; separator=", ">)
<elseif(end.entity)>
  (entity)
<elseif(end.pathParameters)>
  (<end.pathParameters:{x |<x.name>}; separator=", ">)
<endif>
%>

/**
 * The names of the path parameter arguments.
 */
endpointPathParameters() ::= <%
<end.pathParameters:{x |<x.name>}; separator=", ">
%>

endpointQueryParameterStub(param) ::= <<
<docString(param.docString)>
def with_<param.underscoreName>(<param.underscoreName>)
  query_parameter('<param.name>', <param.underscoreName>);
end

>>
