module(requires) ::= <<
# Generated File - DO NOT EDIT

<requires:{x |require "<x>"}; wrap, separator="\n">
>>

version() ::= <<
# Generated File - DO NOT EDIT

module <names.moduleName>
  VERSION = "<names.gemVersion>"
end
>>

entity(entity) ::= <<
# Generated File - DO NOT EDIT

<if(entity.supertype.requireName)>
require '<entity.supertype.requireName>'
<endif>

module <names.moduleName>
  module <names.modelModuleName> 

    <docString(entity.docString)>
    class <entity.simpleName> <if(entity.supertype.simpleName)>\< <entity.supertype.simpleName><endif>
  
      <entity.properties:field(); separator="\n">
    
    end
  end
end
>>

enum(enum, packageName) ::= <<
// Generated File - DO NOT EDIT
package <packageName>;

<docString(enum.docString)>
public enum <enum> {
  <enum.enumValues:{x |<x>}; separator=",\n">;
}
>>

field(property) ::= <%
<docString(property.docString)>

attr_accessor :<property.attrName>
%>

/**
 * Emit a doc string, reflowed to fit the current context.
 */
docString(docString) ::= <<
<if(docString)>
# <docString.chunks; wrap="\n# ", separator=" ">
<endif>
>>

/**
 * Create property security annotation. The kind parameter should be a string
 * either "getter" or "setter".  The property.({template}) allows for dynamic lookup
 * based on the value of kind.
 */
propertyRoles(kind) ::= <%
<if(property.({<kind>PermitAll}))>
  @<names.PermitAll>
<elseif(property.({<kind>RoleNames}))>
  @<names.RolesAllowed>({<property.({<kind>RoleNames}):{x|"<x>"}; separator=", ">})
<endif>
%>

/**
 * Generate an API accessor stub.
 */
api(api) ::= <<
# Generated File - DO NOT EDIT
require 'flatpack_client'

module <names.moduleName>
  class Api \< Flatpack::Client::BaseApi
  
    def initialize(flatpack)
      @flatpack = flatpack
    end
      
    <api.endpoints:endpoint(); separator="\n">
    
    private
    
    <api.endpoints:endpointPrivate()>
    
  end
end
>>

endpointPrivate(end) ::= <%

<if(end.returnType)>
  <endpointPrivateFlatPack(end)>
<else>
  <endpointPrivateConnectionResponse(end)>
<endif> 

%>

endpointPrivateFlatPack(end) ::= <%

<if(end.queryParameters)>
<\n>
<\n>
class <end.className> \< Flatpack::Client::FlatpackRequest
  <end.queryParameters:endpointQueryParameterStub(); separator="\n">
<\n>
end
<endif>

%>

endpointPrivateConnectionResponse(end) ::= <%
<if(end.queryParameters)>
<\n>
<\n>
class <end.className> \< Flatpack::Client::ConnectionRequest
  <end.queryParameters:endpointQueryParameterStub(); separator="\n">
<\n>
end
<endif>

%>

/**
 * Select the kind of endpoint, either one that's documented to return a FlatPackEntity
 * or just return a HttpURLConnection for anything else.
 */
endpoint(end) ::= <%
  <\n>
  <docString(end.docString)>
  def <end.methodName><endpointArgList()><\n>
    <if(end.queryParameters)>
      to_return = <end.className>.new(<end.pathParameters:{x|<x.name>}; separator=", ">)
    <else>
      <if(end.returnType)>
      to_return = Flatpack::Client::FlatpackRequest.new(<end.pathParameters:{x|<x.name>}; separator=", ">)
      <else>
      to_return = Flatpack::Client::ConnectionRequest.new(<end.pathParameters:{x|<x.name>}; separator=", ">)
      <endif>
    <endif>
    <\n>
    <if(end.entity)>to_return.entity = entity<\n><endif>
    to_return<\n>
  end
%>

endpointArgList() ::= <%
<if(end.entity && end.pathParameters)>
  (entity, <end.pathParameters:{x |<x.name>}; separator=", ">)
<elseif(end.entity)>
  (entity)
<elseif(end.pathParameters)>
  (<end.pathParameters:{x |<x.name>}; separator=", ">)
<endif>
%>

/**
 * Make a call to FlatPackTypes.createType() for a synthetic Type reference.
 */
endpointCreateType(type) ::= <%
<names.FlatPackTypes>.createType(<type.flatTypes:{x|<x>.class}; separator=", ">)
%>

/**
 * The names of the path parameter arguments.
 */
endpointPathParameters() ::= <%
<end.pathParameters:{x |<x.name>}; separator=", ">
%>

endpointQueryParameterStub(param) ::= <<
  <docString(param.docString)>
  def with_<param.underscoreName>(<param.underscoreName>)
    query_parameter('<param.name>', <param.underscoreName>);
  end
>>

typeSource(allEntities, packageName, namePrefix) ::= <<
// Generated File - DO NOT EDIT
package <packageName>;
public class <namePrefix>TypeSource implements <names.TypeSource> {
  private static final <names.Set>\<Class\<?\>\> classes = <names.Collections>.unmodifiableSet(
    new <names.HashSet>\<Class\<?\>\>(<names.Arrays>.\<Class\<?\>\>asList(
      <allEntities:{x |<x>.class}; wrap, separator=", ">
    )));
  private static final <names.TypeSource> instance = new <namePrefix>TypeSource();
  
  public static <names.TypeSource> get() {
    return instance;
  }

  public <names.Set>\<Class\<?\>\> getTypes() {
    return classes;
  }
  
  private <namePrefix>TypeSource(){}
}
>>
